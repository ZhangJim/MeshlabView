<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>OBJ 模型查看器</title>
    <!-- 使用说明的样式 -->
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        .help-icon {
            width: 20px;
            height: 20px;
            background: #2196F3;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin-left: auto;
        }
        .help-tooltip {
            display: none;
            position: absolute;
            top: 50%;
            left: calc(100% + 10px); /* 向右偏移 */
            transform: translateY(-50%); /* 垂直居中 */
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .help-tooltip h3 {
            margin: 0 0 10px 0;
            font-size: 15px;
            color: #2196F3;
        }
        .help-tooltip p {
            margin: 8px 0;
        }
        .help-tooltip ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        .help-tooltip li {
            margin: 5px 0;
        }
        .help-icon:hover + .help-tooltip {
            display: block;
        }
        .help-tooltip:before {
            content: '';
            position: absolute;
            top: 50%;
            left: -6px; /* 箭头位置调整到左侧 */
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 6px solid rgba(0, 0, 0, 0.9); /* 箭头指向左侧 */
        }
    </style>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        #file-input {
            margin-bottom: 10px;
            display: none;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .slider {
            width: 150px;
        }
        #viewport-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        .viewport-button {
            width: 40px;
            height: 40px;
            margin: 5px;
            background: #444;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        .viewport-button:hover {
            background: #666;
        }
        .toggle-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #2196F3;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        .model-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #555;
        }
        .model-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .model-item input[type="number"] {
            width: 60px;
            margin: 0 5px;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 2px 5px;
        }
        .model-item button {
            margin-left: 5px;
            background: #444;
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        .model-item button:hover {
            background: #666;
        }
        /* 场景管理样式 */
        #scene-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            width: 300px;
        }

        #save-scene {
            width: 100%;
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
            font-size: 14px;
        }

        #save-scene:hover {
            background: #1976D2;
        }

        .saved-scene {
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .saved-scene div {
            flex: 1;
            margin-right: 10px;
            word-break: break-all;
            font-size: 13px;
        }

        .saved-scene button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
        }

        .saved-scene button:hover {
            background: #666;
        }

        .saved-scene button:last-child {
            background: #d32f2f;
        }

        .saved-scene button:last-child:hover {
            background: #b71c1c;
        }

        #scene-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        #scene-list::-webkit-scrollbar {
            width: 6px;
        }

        #scene-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #scene-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .model-controls h3 {
            display: inline-block;
            margin-right: 10px;
        }
        
        .add-model-btn {
            display: inline-block;
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        .add-model-btn:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
   
    
    <div id="controls">
        <!-- 在 controls div 中添加 -->
<div class="scene-controls">
    <button id="save-scene">保存对比场景</button>
    <div id="saved-scenes">
        <div id="scene-list"></div>
    </div>
</div>

<style>
    .scene-controls {
        margin-top: 20px;
        padding-top: 10px;
        border-top: 1px solid #555;
    }
    .saved-scene {
        background: rgba(255,255,255,0.1);
        margin: 10px 0;
        padding: 10px;
        border-radius: 5px;
    }
    .scene-link {
        color: #2196F3;
        word-break: break-all;
        margin: 5px 0;
        display: block;
    }
</style>
        <input type="file" id="file-input" accept=".obj,.mtl,.jpg,.jpeg,.png" multiple><br>
        <div class="slider-container">
            <label for="brightness-slider">亮度:</label>
            <input type="range" id="brightness-slider" class="slider" min="0" max="200" value="100">
            <span id="brightness-value">100%</span>
        </div>
        <div class="toggle-container">
            <label for="wireframe-toggle">白模显示:</label>
            <label class="toggle-switch">
                <input type="checkbox" id="wireframe-toggle">
                <span class="toggle-slider"></span>
            </label>
            <div class="help-icon" >?</div>
            <div class="help-tooltip">
                <h3>功能说明</h3>
                <p>介绍：用于展示模型对比效果，可以上传彦博生成的多份模型，然后调整位置，进行对比头部模型</p>
                <p>1. 添加模型：点击"添加新模型"按钮上传模型文件（支持.obj/.mtl/.jpg），需要上传彦博生成的模型中的这三种文件；如果想要对比多个模型，可以上传多个彦博生成的模型包</p>
                <p>2. 调整位置：通过模型列表中的X/Y/Z坐标调整模型位置；点住鼠标右键可以拖动整体画布</p>
                <p style="color: #ff0000;">3. 一次对比后，如果想要重新对比其他模型，需要手动刷新页面再次添加模型</p>
                <p>4. 场景管理：</p>
                <ul>
                    <li>保存对比场景：如果想要以后也查看这次对比，可以点击"保存对比场景"按钮</li>
                    <li>加载对比场景：点击场景列表中的"加载"按钮，加载历史对比内容</li>
                    <li>重命名：双击场景名称可以重命名，点击回车进行保存</li>
                    <li>删除对比场景：点击场景列表中的"删除"按钮</li>
                </ul>
                <p>4. 视图控制：</p>
                <ul>
                    <li>亮度调节：使用亮度滑块调整场景亮度</li>
                    <li>白模显示切换开关显示白模效果</li>
                    <li>滑轮控制：使用滑轮控制模型缩放</li>
                </ul>
            </div>
        </div>
        <div class="model-controls">
            <h3>模型列表</h3>
            <button id="add-model" class="add-model-btn">添加模型</button>
            <div id="model-list"></div>
        </div>
    </div>

    <!-- 添加视口控制按钮 -->
    <div id="viewport-controls">
        <button class="viewport-button" id="zoom-in">+</button>
        <button class="viewport-button" id="zoom-out">-</button>
        <button class="viewport-button" id="move-up">↑</button>
        <button class="viewport-button" id="move-down">↓</button>
        <button class="viewport-button" id="reset">R</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        // 在 script 标签开始处添加 toast 函数
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // 添加显示动画
            setTimeout(() => toast.classList.add('show'), 100);
            
            // 3秒移除
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 3000);
            }, 3000);
        }

        // 添加对应的样式
        const style = document.createElement('style');
        style.textContent = `
            .toast {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 24px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                border-radius: 4px;
                z-index: 1000;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease;
            }
            .toast.show {
                opacity: 1;
                transform: translateY(0);
            }
            .toast-success {
                background: rgba(76, 175, 80, 0.9);
            }
            .toast-error {
                background: rgba(244, 67, 54, 0.9);
            }
        `;
        document.head.appendChild(style);

        // 添加确认弹层的样式
        const confirmStyle = document.createElement('style');
        confirmStyle.textContent = `
            .confirm-dialog {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2a2a2a;
                padding: 20px;
                border-radius: 8px;
                color: white;
                z-index: 1000;
                min-width: 300px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            }
            .confirm-dialog h3 {
                margin: 0 0 15px 0;
                font-size: 16px;
            }
            .confirm-dialog .buttons {
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            }
            .confirm-dialog button {
                padding: 8px 15px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            .confirm-dialog .confirm-btn {
                background: #d32f2f;
                color: white;
            }
            .confirm-dialog .cancel-btn {
                background: #666;
                color: white;
            }
            .confirm-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 999;
            }
        `;
        document.head.appendChild(confirmStyle);

        // 添加确认对话框函数
        function showConfirmDialog(message) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'confirm-overlay';
                
                const dialog = document.createElement('div');
                dialog.className = 'confirm-dialog';
                dialog.innerHTML = `
                    <h3>确认删除</h3>
                    <p>${message}</p>
                    <div class="buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="confirm-btn">确认删除</button>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                document.body.appendChild(dialog);
                
                dialog.querySelector('.confirm-btn').addEventListener('click', () => {
                    overlay.remove();
                    dialog.remove();
                    resolve(true);
                });
                
                dialog.querySelector('.cancel-btn').addEventListener('click', () => {
                    overlay.remove();
                    dialog.remove();
                    resolve(false);
                });
            });
        }

        // 在 window.addEventListener('load', function() { 之前添加全局函数
        window.deleteScene = async function(filename) {
            try {
                // 显示确认对话框
                const confirmed = await showConfirmDialog('确定要删除这个场景吗？');
                if (!confirmed) return;
                
                const response = await fetch(`/scenes/${filename}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // 获取最新的场景列表
                    const listResponse = await fetch('/list-scenes');
                    const scenes = await listResponse.json();
                    
                    // 更新场景列表UI
                    const sceneList = document.getElementById('scene-list');
                    sceneList.innerHTML = '';
                    
                    scenes.forEach(scene => {
                        const sceneElement = document.createElement('div');
                        sceneElement.className = 'saved-scene';
                        sceneElement.innerHTML = `
                            <div>${scene.filename}</div>
                            <button onclick="loadScene('${scene.filename}')">加载</button>
                            <button onclick="deleteScene('${scene.filename}')">删除</button>
                        `;
                        sceneList.appendChild(sceneElement);
                    });
                    
                    showToast('景删除成功', 'success');
                } else {
                    const error = await response.json();
                    throw new Error(error.error || '删除失败');
                }
            } catch (error) {
                console.error('删除场景失败:', error);
                showToast('删除场景失败: ' + error.message, 'error');
            }
        };

        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                console.error('THREE.js 未加载');
                return;
            }
            
            let scene, camera, renderer, controls;
            let lights = [];
            let currentModel = null;
            window.models = []; // 改为全局变量
            window.scene = null; // 添加全局场景引用
            window.camera = null; // 添加全局相机引用
            window.controls = null; // 添加全局控制器引用

            function init() {
                try {
                    scene = new THREE.Scene();
                    window.scene = scene; // 保存全局引用
                    scene.background = new THREE.Color(0x2a2a2a);

                    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
                    window.camera = camera; // 保存全局引用
                    camera.position.set(0, 2, 5);

                    renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        precision: 'highp',
                        alpha: true,
                        preserveDrawingBuffer: true
                    });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.outputEncoding = THREE.sRGBEncoding;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.0;
                    document.body.appendChild(renderer.domElement);

                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    window.controls = controls; // 保存全局引用
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.screenSpacePanning = true;

                    // 重新设置光源并存储到数组中
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                    scene.add(ambientLight);
                    lights.push(ambientLight);

                    const frontLight = new THREE.DirectionalLight(0xffffff, 0.3);
                    frontLight.position.set(0, 0, 1);
                    scene.add(frontLight);
                    lights.push(frontLight);

                    const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
                    topLight.position.set(0, 1, 0);
                    scene.add(topLight);
                    lights.push(topLight);

                    // 加亮度控制
                    const brightnessSlider = document.getElementById('brightness-slider');
                    const brightnessValue = document.getElementById('brightness-value');
                    
                    brightnessSlider.addEventListener('input', function(e) {
                        const value = e.target.value / 100;
                        brightnessValue.textContent = e.target.value + '%';
                        
                        // 调整所有光源的强度
                        lights.forEach(light => {
                            if (light.isAmbientLight) {
                                light.intensity = value * 0.4; // 环境光基础强度是 0.4
                            } else if (light.isDirectionalLight) {
                                light.intensity = value * 0.3; // 方向光基础强度是 0.3
                            }
                        });
                    });

                    // 添加视口控制
                    const zoomStep = 0.5;
                    const moveStep = 0.5;

                    document.getElementById('zoom-in').addEventListener('click', () => {
                        camera.position.z -= zoomStep;
                        controls.update();
                    });

                    document.getElementById('zoom-out').addEventListener('click', () => {
                        camera.position.z += zoomStep;
                        controls.update();
                    });

                    document.getElementById('move-up').addEventListener('click', () => {
                        camera.position.y += moveStep;
                        controls.target.y += moveStep;
                        controls.update();
                    });

                    document.getElementById('move-down').addEventListener('click', () => {
                        camera.position.y -= moveStep;
                        controls.target.y -= moveStep;
                        controls.update();
                    });

                    document.getElementById('reset').addEventListener('click', () => {
                        camera.position.set(0, 2, 5);
                        controls.target.set(0, 0, 0);
                        controls.update();
                    });

                    // 添加键盘控制
                    window.addEventListener('keydown', (e) => {
                        switch(e.key) {
                            case '=': // 大
                            case '+':
                                camera.position.z -= zoomStep;
                                break;
                            case '-': // 缩小
                            case '_':
                                camera.position.z += zoomStep;
                                break;
                            case 'ArrowUp': // 向上移动
                                camera.position.y += moveStep;
                                controls.target.y += moveStep;
                                break;
                            case 'ArrowDown': // 向下移动
                                camera.position.y -= moveStep;
                                controls.target.y -= moveStep;
                                break;
                            case 'r': // 重置视图
                            case 'R':
                                camera.position.set(0, 2, 5);
                                controls.target.set(0, 0, 0);
                                break;
                        }
                        controls.update();
                    });

                    animate();
                } catch (error) {
                    console.error('初始化错误:', error);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }

            function loadOBJFile(objFile, mtlFile, textureFiles, position = { x: 0, y: 0, z: 0 }) {
                if (mtlFile && textureFiles.length > 0) {
                    const textureFile = textureFiles[0];
                    
                    // 首先上传文件
                    const uploadFiles = async () => {
                        try {
                            console.log("开始上传文件");
                            
                            // 上传OBJ文件
                            const objFormData = new FormData();
                            objFormData.append('file', objFile);
                            console.log("上传OBJ文件:", objFile.name);
                            
                            const objResponse = await fetch('/upload', {
                                method: 'POST',
                                body: objFormData
                            });
                            
                            if (!objResponse.ok) {
                                const errorText = await objResponse.text();
                                console.error("OBJ文件上传失败:", errorText);
                                throw new Error(`OBJ文件上传失败: ${errorText}`);
                            }
                            
                            const objResult = await objResponse.json();
                            console.log("OBJ文件上传成功:", objResult);
                            
                            // 上传MTL文件
                            const mtlFormData = new FormData();
                            mtlFormData.append('file', mtlFile);
                            console.log("上传MTL文件:", mtlFile.name);
                            
                            const mtlResponse = await fetch('/upload', {
                                method: 'POST',
                                body: mtlFormData
                            });
                            
                            if (!mtlResponse.ok) {
                                const errorText = await mtlResponse.text();
                                console.error("MTL文件上传失败:", errorText);
                                throw new Error(`MTL文件上传失败: ${errorText}`);
                            }
                            
                            const mtlResult = await mtlResponse.json();
                            console.log("MTL文件上传成功:", mtlResult);
                            
                            // 上传贴图文件
                            const textureFormData = new FormData();
                            textureFormData.append('file', textureFile);
                            console.log("上传贴图文件:", textureFile.name);
                            
                            const textureResponse = await fetch('/upload', {
                                method: 'POST',
                                body: textureFormData
                            });
                            
                            if (!textureResponse.ok) {
                                const errorText = await textureResponse.text();
                                console.error("贴图文件上传失败:", errorText);
                                throw new Error(`贴图文件上传失败: ${errorText}`);
                            }
                            
                            const textureResult = await textureResponse.json();
                            console.log("贴图文件上传成功:", textureResult);
                            
                            return {
                                objPath: objResult.filepath,
                                mtlPath: mtlResult.filepath,
                                texturePath: textureResult.filepath,
                                files: {
                                    obj: objFile,
                                    mtl: mtlFile,
                                    texture: textureFile
                                }
                            };
                        } catch (error) {
                            console.error('文件上传失败:', error);
                            throw error;
                        }
                    };
                    
                    // 上传文件并加载模型
                    uploadFiles().then(paths => {
                        const texture = new THREE.TextureLoader().load(paths.texturePath);
                        texture.encoding = THREE.sRGBEncoding;
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        
                        const mtlLoader = new THREE.MTLLoader();
                        mtlLoader.load(paths.mtlPath, function(materials) {
                            materials.preload();
                            
                            Object.values(materials.materials).forEach(material => {
                                material.map = texture;
                                material.needsUpdate = true;
                            });
                            
                            const objLoader = new THREE.OBJLoader();
                            objLoader.setMaterials(materials);
                            
                            objLoader.load(paths.objPath, function(object) {
                                // 调整模大小和位置
                                const box = new THREE.Box3().setFromObject(object);
                                const center = box.getCenter(new THREE.Vector3());
                                const size = box.getSize(new THREE.Vector3());
                                const maxDim = Math.max(size.x, size.y, size.z);
                                const scale = 2 / maxDim;
                                
                                object.scale.multiplyScalar(scale);
                                object.position.copy(center).multiplyScalar(-1 * scale);
                                
                                // 应用指定位置
                                object.position.x += position.x;
                                object.position.y += position.y;
                                object.position.z += position.z;
                                
                                // 将模型添加到场景和模型列表
                                scene.add(object);
                                const modelIndex = models.length;
                                models.push({
                                    object: object,
                                    position: position,
                                    files: paths.files,
                                    savedFiles: {
                                        objFile: paths.objPath,
                                        mtlFile: paths.mtlPath,
                                        textureFile: paths.texturePath
                                    }
                                });
                                
                                // 添加到UI列表
                                addModelToList(modelIndex);
                                
                                // 检查白模状态
                                const wireframeEnabled = document.getElementById('wireframe-toggle').checked;
                                if (wireframeEnabled) {
                                    toggleWireframe(true);
                                }
                                
                                // 清理 URL
                                URL.revokeObjectURL(paths.texturePath);
                                URL.revokeObjectURL(paths.mtlPath);
                                URL.revokeObjectURL(paths.objPath);
                            });
                        });
                    }).catch(error => {
                        console.error('模型加载失败:', error);
                        alert('模型加载失败: ' + error.message);
                    });
                }
            }

            // 添加模型到UI列表
            function addModelToList(index) {
                const modelList = document.getElementById('model-list');
                const modelItem = document.createElement('div');
                modelItem.className = 'model-item';
                modelItem.innerHTML = `
                    <span>模型 ${index + 1}</span>
                    <label>X: <input type="number" class="pos-x" value="${models[index].position.x}" step="0.5"></label>
                    <label>Y: <input type="number" class="pos-y" value="${models[index].position.y}" step="0.5"></label>
                    <label>Z: <input type="number" class="pos-z" value="${models[index].position.z}" step="0.5"></label>
                    <button class="remove-model">删除</button>
                `;
                
                // 添加位置控事件
                const inputs = modelItem.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    input.addEventListener('change', function() {
                        const x = parseFloat(modelItem.querySelector('.pos-x').value);
                        const y = parseFloat(modelItem.querySelector('.pos-y').value);
                        const z = parseFloat(modelItem.querySelector('.pos-z').value);
                        models[index].object.position.set(x, y, z);
                    });
                });
                
                // 添加删除按钮事件
                modelItem.querySelector('.remove-model').addEventListener('click', function() {
                    scene.remove(models[index].object);
                    models.splice(index, 1);
                    updateModelList();
                });
                
                modelList.appendChild(modelItem);
            }

            // 更新模列表UI
            function updateModelList() {
                const modelList = document.getElementById('model-list');
                modelList.innerHTML = '';
                models.forEach((model, index) => {
                    addModelToList(index);
                });
            }

            // 添加新模型按钮事件
            document.getElementById('add-model').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });

            // 修改文件输入监听器
            document.getElementById('file-input').addEventListener('change', function(event) {
                const files = Array.from(event.target.files);
                const objFile = files.find(f => f.name.toLowerCase().endsWith('.obj'));
                const mtlFile = files.find(f => f.name.toLowerCase().endsWith('.mtl'));
                const textureFiles = files.filter(f => /\.(jpg|jpeg|png|gif)$/i.test(f.name));
                
                if (objFile) {
                    // 修改新模型的位置计算
                    const offset = models.length * 0.5; // 减小间距为0.5个单位
                    loadOBJFile(objFile, mtlFile, textureFiles, { x: offset, y: 0, z: 0 });
                }
            });

            init();

            window.addEventListener('resize', function() {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });

            // 获取景数据
            function getSceneData() {
                const sceneData = {
                    models: models.map(model => ({
                        position: {
                            x: model.object.position.x,
                            y: model.object.position.y,
                            z: model.object.position.z
                        },
                        rotation: {
                            x: model.object.rotation.x,
                            y: model.object.rotation.y,
                            z: model.object.rotation.z
                        },
                        scale: {
                            x: model.object.scale.x,
                            y: model.object.scale.y,
                            z: model.object.scale.z
                        }
                    })),
                    camera: {
                        position: {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        },
                        rotation: {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        }
                    },
                    settings: {
                        wireframe: document.getElementById('wireframe-toggle').checked,
                        brightness: document.getElementById('brightness-slider').value
                    }
                };
                return sceneData;
            }

            // 修改保存场景函数
            async function saveScene() {
                try {
                    // 准��场景数据
                    const sceneData = {
                        models: models.map(model => ({
                            // 使用完整的文件路径
                            objFile: model.savedFiles.objFile,      // 包含完整路径
                            mtlFile: model.savedFiles.mtlFile,      // 包含完整路径
                            textureFile: model.savedFiles.textureFile,  // 包含完整路径
                            position: {
                                x: model.object.position.x,
                                y: model.object.position.y,
                                z: model.object.position.z
                            },
                            rotation: {
                                x: model.object.rotation.x,
                                y: model.object.rotation.y,
                                z: model.object.rotation.z
                            },
                            scale: {
                                x: model.object.scale.x,
                                y: model.object.scale.y,
                                z: model.object.scale.z
                            }
                        })),
                        camera: {
                            position: {
                                x: camera.position.x,
                                y: camera.position.y,
                                z: camera.position.z
                            },
                            rotation: {
                                x: camera.rotation.x,
                                y: camera.rotation.y,
                                z: camera.rotation.z
                            }
                        },
                        settings: {
                            wireframe: document.getElementById('wireframe-toggle').checked,
                            brightness: document.getElementById('brightness-slider').value
                        }
                    };

                    console.log('Saving scene data:', sceneData); // 添加日志

                    const response = await fetch('/save-scene', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(sceneData)
                    });
                    
                    const result = await response.json();
                    if(result.success) {
                        showToast('场景保存成功', 'success');
                        loadSceneList();
                    } else {
                        throw new Error(result.error || '保存失败');
                    }
                } catch (error) {
                    console.error('保存失败:', error);
                    showToast('保存失败: ' + error.message, 'error');
                }
            }

            // 修改 loadSceneList 函数
            async function loadSceneList() {
                try {
                    const response = await fetch('/list-scenes');
                    const scenes = await response.json();
                    const sceneList = document.getElementById('scene-list');
                    sceneList.innerHTML = '';
                    
                    scenes.forEach(scene => {
                        const sceneElement = document.createElement('div');
                        sceneElement.className = 'saved-scene';
                        
                        // 创建文件名容器，移除 .json 后缀
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'scene-name';
                        nameSpan.textContent = scene.filename.replace('.json', '');  // 移除 .json 后缀
                        nameSpan.title = '双击重命名';
                        
                        // 添加双击事件监听器
                        nameSpan.addEventListener('dblclick', async function(e) {
                            const oldName = scene.filename;
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.value = oldName.replace('.json', '');
                            input.className = 'rename-input';
                            
                            // 替换原有的文本为输入框
                            this.replaceWith(input);
                            input.focus();
                            input.select();
                            
                            // 处理输入完成
                            const handleRename = async () => {
                                let newName = input.value.trim();
                                if (newName && newName !== oldName.replace('.json', '')) {
                                    try {
                                        const response = await fetch(`/scenes/${oldName}/rename`, {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                            },
                                            body: JSON.stringify({ newName: newName })
                                        });
                                        
                                        const result = await response.json();
                                        
                                        if (response.ok && result.success) {
                                            showToast('重命名成功', 'success');
                                            await loadSceneList(); // 刷新列表
                                            return; // 成功后直接返回，不执行后面的代码
                                        }
                                        
                                        // 如果到这里，说明重命名失败
                                        throw new Error(result.error || '重命名失败');
                                    } catch (error) {
                                        console.error('重命名失败:', error);
                                        showToast('重命名失败: ' + error.message, 'error');
                                        input.replaceWith(nameSpan); // 恢复原来的名字
                                    }
                                } else {
                                    // 如果名字没有改变，直接恢复原来的名字，不显示任何提示
                                    input.replaceWith(nameSpan);
                                }
                            };
                            
                            // 添加事件监听
                            input.addEventListener('blur', handleRename);
                            input.addEventListener('keypress', function(e) {
                                if (e.key === 'Enter') {
                                    handleRename();
                                }
                            });
                        });
                        
                        // 创建按钮容器
                        const buttonsDiv = document.createElement('div');
                        buttonsDiv.className = 'scene-buttons';
                        buttonsDiv.innerHTML = `
                            <button onclick="loadScene('${scene.filename}')">加载</button>
                            <button onclick="deleteScene('${scene.filename}')">删除</button>
                        `;
                        
                        // 组装元素
                        sceneElement.appendChild(nameSpan);
                        sceneElement.appendChild(buttonsDiv);
                        sceneList.appendChild(sceneElement);
                    });
                } catch (error) {
                    console.error('加载场景列表失败:', error);
                    showToast('加载场景列表失败', 'error');
                }
            }

            // 在页面加载完成后添加事件监听
            document.getElementById('save-scene').addEventListener('click', saveScene);
            // 初始加载场景列表
            loadSceneList();

            // 在这里定义 window.loadScene
            window.loadScene = async function(filename) {
                try {
                    const response = await fetch(`/scenes/${filename}`);
                    const sceneData = await response.json();
                    
                    console.log('Loading scene data:', sceneData);
                    
                    // 清除当前场景中的所有模型
                    window.models.forEach(model => {
                        if (model.object) {
                            window.scene.remove(model.object);
                        }
                    });
                    window.models = [];
                    
                    // 加载模型文件
                    if (Array.isArray(sceneData.models)) {
                        for (const modelData of sceneData.models) {
                            try {
                                const objPath = modelData.objFile;
                                const mtlPath = modelData.mtlFile;
                                const texturePath = modelData.textureFile;
                                
                                console.log('Loading model files:', {objPath, mtlPath, texturePath});
                                
                                // 从服务器获取模型文件
                                const objResponse = await fetch(objPath);
                                const mtlResponse = await fetch(mtlPath);
                                const textureResponse = await fetch(texturePath);
                                
                                if (!objResponse.ok || !mtlResponse.ok || !textureResponse.ok) {
                                    throw new Error('无法加载模型文件');
                                }
                                
                                const objBlob = await objResponse.blob();
                                const mtlBlob = await mtlResponse.blob();
                                const textureBlob = await textureResponse.blob();
                                
                                // 创建文件的 URL
                                const objUrl = URL.createObjectURL(objBlob);
                                const mtlUrl = URL.createObjectURL(mtlBlob);
                                const textureUrl = URL.createObjectURL(textureBlob);
                                
                                // 先加载纹理
                                const texture = await new Promise((resolve, reject) => {
                                    const textureLoader = new THREE.TextureLoader();
                                    textureLoader.load(
                                        textureUrl,
                                        (texture) => {
                                            texture.encoding = THREE.sRGBEncoding;
                                            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                            resolve(texture);
                                        },
                                        undefined,
                                        reject
                                    );
                                });
                                
                                // 加载材质和模型
                                await new Promise((resolve, reject) => {
                                    const mtlLoader = new THREE.MTLLoader();
                                    mtlLoader.load(mtlUrl, (materials) => {
                                        materials.preload();
                                        
                                        // 应用纹理到所有材质
                                        Object.values(materials.materials).forEach(material => {
                                            material.map = texture;
                                            material.needsUpdate = true;
                                        });
                                        
                                        const objLoader = new THREE.OBJLoader();
                                        objLoader.setMaterials(materials);
                                        
                                        objLoader.load(objUrl, (object) => {
                                            // 应用保存的变换
                                            object.position.set(
                                                modelData.position.x,
                                                modelData.position.y,
                                                modelData.position.z
                                            );
                                            object.rotation.set(
                                                modelData.rotation.x,
                                                modelData.rotation.y,
                                                modelData.rotation.z
                                            );
                                            object.scale.set(
                                                modelData.scale.x,
                                                modelData.scale.y,
                                                modelData.scale.z
                                            );
                                            
                                            // 添加到场景
                                            window.scene.add(object);
                                            
                                            // 保存到模型列表
                                            window.models.push({
                                                object: object,
                                                position: modelData.position,
                                                savedFiles: {
                                                    objFile: objPath,
                                                    mtlFile: mtlPath,
                                                    textureFile: texturePath
                                                }
                                            });
                                            
                                            // 清理URL
                                            URL.revokeObjectURL(objUrl);
                                            URL.revokeObjectURL(mtlUrl);
                                            URL.revokeObjectURL(textureUrl);
                                            
                                            // 更新UI
                                            updateModelList();
                                            
                                            resolve();
                                        }, undefined, reject);
                                    }, undefined, reject);
                                });
                                
                            } catch (error) {
                                console.error('加载模型失败:', error);
                                showToast('加载模型失败: ' + error.message, 'error');
                            }
                        }
                    }
                    
                    // 应用场景设置
                    if (sceneData.settings) {
                        document.getElementById('wireframe-toggle').checked = sceneData.settings.wireframe;
                        document.getElementById('brightness-slider').value = sceneData.settings.brightness;
                        const event = new Event('input');
                        document.getElementById('brightness-slider').dispatchEvent(event);
                    }
                    
                    // 加载相机位置
                    if (sceneData.camera) {
                        camera.position.set(
                            sceneData.camera.position.x,
                            sceneData.camera.position.y,
                            sceneData.camera.position.z
                        );
                        camera.rotation.set(
                            sceneData.camera.rotation.x,
                            sceneData.camera.rotation.y,
                            sceneData.camera.rotation.z
                        );
                        controls.update();
                    }
                    
                    showToast('场景加载成功', 'success');
                } catch (error) {
                    console.error('加载场景失败:', error);
                    showToast('加载场景失败: ' + error.message, 'error');
                }
            };

            // 确保在页面加载时调用
            loadSceneList();

            // 在 window.addEventListener('load', function() { 内添加 toggleWireframe 函数
            function toggleWireframe(enabled) {
                models.forEach(modelData => {
                    if (modelData.object) {
                        modelData.object.traverse(function(child) {
                            if (child.isMesh) {
                                if (enabled) {
                                    // 保存原始材质
                                    if (!child.userData.originalMaterial) {
                                        child.userData.originalMaterial = child.material;
                                    }
                                    // 创建白模材质
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xcccccc,
                                        roughness: 0.7,
                                        metalness: 0.0,
                                        wireframe: false,
                                        side: THREE.DoubleSide
                                    });
                                } else {
                                    // 恢复原始材质
                                    if (child.userData.originalMaterial) {
                                        child.material = child.userData.originalMaterial;
                                    }
                                }
                            }
                        });
                    }
                });
            }

            // 添加白模切换监听器
            document.getElementById('wireframe-toggle').addEventListener('change', function(e) {
                toggleWireframe(e.target.checked);
            });

            // 添加样式
            const style = document.createElement('style');
            style.textContent += `
                .scene-name {
                    cursor: pointer;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .scene-name:hover {
                    background: rgba(255,255,255,0.1);
                }
                .rename-input {
                    background: #333;
                    border: 1px solid #555;
                    color: white;
                    padding: 2px 5px;
                    border-radius: 3px;
                    width: 200px;
                }
                .scene-buttons {
                    display: flex;
                    gap: 5px;
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html> 